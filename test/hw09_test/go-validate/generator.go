package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

const (
	outFileNameSuffix string = "_validation_generated"
)

type structField struct {
	Name string
	Type string
	Tag  string
}

var (
	ErrCannotReadFile     = errors.New("can not read file")
	ErrCannotParseFile    = errors.New("can not parse file")
	ErrCannotWriteFile    = errors.New("can not write file")
	ErrCannotBuildCode    = errors.New("can not build code")
	ErrCannotBuildFunc    = errors.New("can not build func")
	ErrCannotFormatSource = errors.New("can not format source")
)

func Generate(sourcePath string) error {
	sourceBytes, err := ioutil.ReadFile(sourcePath)
	if err != nil {
		return fmt.Errorf("%s: %w", ErrCannotReadFile, err)
	}

	fileSet := token.NewFileSet()
	f, err := parser.ParseFile(fileSet, sourcePath, sourceBytes, 0)
	if err != nil {
		return fmt.Errorf("%s: %w", ErrCannotParseFile, err)
	}

	outSourceCode, err := buildSource(f)
	if err != nil {
		return fmt.Errorf("%s: %w", ErrCannotBuildCode, err)
	}

	var extension string
	sepIndex := strings.LastIndex(sourcePath, string(os.PathSeparator))
	dotIndex := strings.LastIndex(sourcePath, ".")
	sourceFileName := sourcePath
	if dotIndex != -1 && dotIndex > sepIndex { // some folder can have name such "foo.bar"
		sourceFileName = sourcePath[:dotIndex]
		extension = sourcePath[dotIndex:]
	}

	outFileName := sourceFileName + outFileNameSuffix + extension
	err = ioutil.WriteFile(outFileName, []byte(outSourceCode), 0644)
	if err != nil {
		return fmt.Errorf("%s: %w", ErrCannotWriteFile, err)
	}

	return nil
}

// buildSource builds validation source code string from input AST tree
func buildSource(f *ast.File) (string, error) {
	var bb bytes.Buffer
	bb.WriteString("// Code generated by go-validate tool. DO NOT EDIT.\n")
	bb.WriteString("package " + f.Name.Name + "\n\n")

	for _, decl := range f.Decls {
		gd, ok := decl.(*ast.GenDecl)   // generic declaration (import, const, type, var)
		if ok && gd.Tok == token.TYPE { // this is a type declaration (maybe with "(...)")
			for _, spec := range gd.Specs {
				if ts, ok := spec.(*ast.TypeSpec); ok {
					if st, ok := ts.Type.(*ast.StructType); ok && st.Fields.List != nil { // struct declaration with fields
						structName := ts.Name.Name
						structFields := make([]structField, 0, st.Fields.NumFields())
						for _, field := range st.Fields.List {
							var fieldName string
							if field.Names != nil {
								fieldName = field.Names[0].Name
							}
							var fieldType string
							if ident, ok := field.Type.(*ast.Ident); ok {
								fieldType = ident.Name
							}
							var fieldTag string
							if field.Tag != nil {
								fieldTag = field.Tag.Value
							}

							if fieldName == "" || fieldType == "" || fieldTag == "" {
								continue
							}

							structFields = append(structFields, structField{
								Name: fieldName,
								Type: fieldType,
								Tag:  fieldTag,
							})
						}
						if len(structFields) > 0 {
							funcString, err := buildFuncString(structName, structFields)
							if err != nil {
								return "", fmt.Errorf("%s: %w", ErrCannotBuildFunc, err)
							}
							bb.WriteString(funcString)
						}
					}
				}
			}
		}
	}

	outBytes, err := format.Source(bb.Bytes())
	if err != nil {
		return "", fmt.Errorf("%s: %w", ErrCannotFormatSource, err)
	}
	return string(outBytes), nil
}

func buildFuncString(structName string, structFields []structField) (string, error) {
	var templText = `func ({{.VarName}} {{.TypeName}}) Validate() ([]ValidationError, error) {
	return nil, nil}

`
	templData := struct {
		VarName  string
		TypeName string
	}{
		VarName:  getVarName(structName),
		TypeName: structName,
	}

	templ, err := template.New("validator").Parse(templText)
	if err != nil {
		return "", err
	}

	var bb bytes.Buffer
	err = templ.Execute(&bb, templData)
	if err != nil {
		return "", nil
	}

	return bb.String(), nil
}

func getVarName(structName string) string {
	if structName == "" {
		return ""
	}

	var sb strings.Builder
	letters := strings.Split(structName, "")
	for _, letter := range letters {
		if strings.ToLower(letter) != letter {
			sb.WriteString(strings.ToLower(letter))
		}
	}

	return sb.String()
}
