{{/* template of validation function */}}
{{define "func"}}
    // Validate validates fields of {{.TypeName}} struct.
    func ({{.VarName}} {{.TypeName}}) Validate() ([]ValidationError, error) {
    var vErrs []ValidationError
    {{$varName := .VarName}}
    {{range .Fields}}
        {{$fieldName := .Name}}
        {{$fieldType := .Type}}
        {{range .Rules}}
            {{/* rules for int */}}
            {{if and (eq $fieldType "int") (eq .Type "min")}}
                if {{$varName}}.{{$fieldName}} < {{.String}} {
                    vErrs = append(vErrs, ValidationError{
                        Field: "{{$fieldName}}",
                        Error: errors.New("{{$fieldName}} must be greater than {{.String}}"),
                    })
                }
            {{else if and (eq $fieldType "int") (eq .Type "max")}}
                if {{$varName}}.{{$fieldName}} > {{.String}} {
                    vErrs = append(vErrs, ValidationError{
                        Field: "{{$fieldName}}",
                        Error: errors.New("{{$fieldName}} must be less than {{.String}}"),
                    })
                }
            {{else if and (eq $fieldType "int") (eq .Type "in")}}
                // {{$fieldName}} in({{.String}})
            {{/* rules for string */}}
            {{else if and (eq $fieldType "string") (eq .Type "len")}}
                if len({{$varName}}.{{$fieldName}}) != {{.String}} {
                    vErrs = append(vErrs, ValidationError{
                        Field: "{{$fieldName}}",
                        Error: errors.New("length of {{$fieldName}} must be {{.String}} characters"),
                    })
                }
            {{else if and (eq $fieldType "string") (eq .Type "regexp")}}
                re, err := regexp.Compile("{{.String}}")
	            if err != nil {
		            return vErrs, err
	            }
	            if !re.Match([]byte({{$varName}}.{{$fieldName}})) {
		            vErrs = append(vErrs, ValidationError{
                        Field: "{{$fieldName}}",
                        Error: errors.New(`{{$fieldName}} is not matching regexp "{{.String}}"`),
                    })
	            }
            {{else if and (eq $fieldType "string") (eq .Type "in")}}
                // {{$fieldName}} in({{.String}})
            {{end}}
        {{end}}
    {{end}}
    return vErrs, nil
}
{{end}}